# 콘서트 매진 랭킹 설계 보고서

# 랭킹 산정 기준
## 좌석 상태
1. 좌석 상태 예약 이상 - 전체 좌석 상태 'AVAILABLE'이 아닐경우 
2. 좌석 상태 결제 이상 - 전체 좌석 상태 'ASSINGED'일 경우

좌석 임시배정 상태(예약)을 매진으로 보는건 애매하다  
최종 결제까지 이루어지지않으면 임시배정은 만료된다  

좀 더 정확한 좌석 상태를 기준으로 사용하는것이 좋다고 판단  

### 결론: **전체 좌석 상태가 배정('ASSIGNED')된 경우를 기준으로 산정**

## 점수 산정
- 티켓팅 오픈 시간부터 마지막 좌석 결제까지의 시간차이를 이용 (마지막 좌석 결제 시간 - 티켓팅 오픈시간)
> **현재 티켓팅 오픈 시간 정보없음 concert 테이블 필드 추가 및 추가 검증 필요함**  
> **concert 테이블 매진시간 필드도 추가**

### 동일 점수 처리 방안
티켓팅 오픈 시간부터 마지막 좌석 결제 시간의 차이가 동일하면 어떻게 처리할것인가
- 전체 좌석수가 많은 콘서트가 우선 순위
   - 현재 날짜별 좌석개수는 50개로 고정되어있음
   - 따라서 콘서트 개최 날짜가 많으면 우선 순위

**그래도 동일하면?**
- 콘서트 티켓팅 오픈시간이 먼저인것이 우선순위로 결정

**정리**
1. (마지막 좌석 결제 시간 - 티켓팅 오픈시간) 짧은 
2. 콘서트 개최 날짜가 많은
3. 오픈시간이 먼저

> 이 정도만 고려해도 동일 점수에 대한 대안이 충분하다고 생각된다  
> 그래도 동일하면 Sorted Set의 정렬 규칙사용

### 추가 고려사항 
#### 콘서트의 명칭이 중복된다면?
> 예) 2023 싸이 흠뻑쇼, 2024 싸이 흠뻑쇼 등

갱신할 것인지 개별 콘서트로 랭킹 산정할 것인지  
**결론: 고유한 concertId별로 랭킹 산정(개별로 본다)**

## 구현 방식 
> Redis Sorted Set 자료구조 사용하여 구현  
> ```ZADD concertSoldOutRank {점수} {ConcertId} ```   

### 점수 계산 방식
```
점수 = 매진시간(초) + (100 - 콘서트 날짜 수) + 오픈시간 타임스탬프(초)
문자열 형식으로 이어붙이고 long 타입으로 변환
예) 
- A콘서트: 300초만에 매진, 5일 개최, 2025-01-01 오픈
- B콘서트: 300초만에 매진, 3일 개최, 2025-01-01 오픈

A콘서트 점수: 300,951,735,689,600
B콘서트 점수: 300,971,735,689,600

A콘서트 점수가 낮음
1. A콘서트
2. B콘서트
```
#### 고려할 점
long 타입 범위 초과 가능성 있지만 가능성 낮음
long 타입 최대범위: 9,223,372,036,854,775,807

매진 시간이 4달 걸린 경우: 10,368,000초  
예시 - 4달만에 매진, 5일 개최, 2025-01-01 오픈   
점수: 10,368,000,971,735,689,600 -> long 타입 범위 초과  

하지만 발생 가능성 아주 낮음 - 고려 X

### 랭킹 갱신 방식
1. 좌석 결제 시 이벤트 발행 -> 비동기 처리
    - 실시간성 좋음
2. 스케줄러 사용
    - 매일 or 시간별 스케줄러 동작
    - 실시간성 부족함

**좌석 결제 시 이벤트 발행** 방식으로 결정

### 랭킹 데이터 집계 방식
랭킹 데이터를 어디까지 집계할지
1. 상위 랭킹만 관리
2. 전체 콘서트

전체 콘서트 랭킹을 관리하지만   
Redis에선 상위 100위까지 랭킹 데이터 관리  
DB에서 전체 콘서트 랭킹 정보 관리(백업용도로도 사용 가능)

> Redis 자체 최대 저장 개수를 지정하는 옵션 부재  
> ZREMRANGEBYRANK key 100 -1 명령어를 통해  
> 랭킹 저장 후 100개까지 잘라줘야함  
> 저장 -> 100위까지 자르기 (Lua 스크립트 활용해 원자적으로 수행)

#### 고려할 점
Redis와 DB의 정합성은 어떻게 관리할 것인지
1. Redis 랭킹 업데이트시 DB 함께 업데이트
2. 스케줄러 사용하여 일정 시간마다 동기화

DB와의 정합성이 실시간으로 보장되지않아도 상관없다고 생각됨  
성능적으로도 스케줄러를 사용해 일정 시간마다 동기화 하는것이 나을것이라 판단

**스케줄러 사용한 동기화 방식 사용**


## 정리
- 랭킹 산정 기준: 전체 좌석 상태 배정('ASSIGNED')기준
- 점수 산정:
    1. 매진시간 짧은 순
    2. 콘서트 날짜 많은 순
    3. 티켓팅 오픈 시간 먼저 인 순
    - 문자열 형식으로 이어붙힌후 long 타입 변환 (long 범위 초과 고려 안함)
- 랭킹 갱신 방식: 좌석 결제 시 이벤트 발행 -> 매진 체크 -> 랭킹 업데이트 
- 랭킹 집계 방식: 
  - 상위 100위까지 Redis에서 관리
  - 전체 콘서트 랭킹 DB에서 관리
  - 스케줄러 사용 일정 시간마다 동기화
- 추가 사항
  - Concert 테이블 오픈 시간, 매진 시간 필드 추가 및 검증 필요

