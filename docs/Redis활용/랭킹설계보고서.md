# 콘서트 매진 랭킹 설계 및 구현 보고서

# 랭킹 산정 기준
## 좌석 상태
1. 좌석 상태 예약 이상 - 전체 좌석 상태 'AVAILABLE'이 아닐경우 
2. 좌석 상태 결제 이상 - 전체 좌석 상태 'ASSINGED'일 경우

좌석 임시배정 상태(예약)을 매진으로 보는건 애매하다  
최종 결제까지 이루어지지않으면 임시배정은 만료된다  

좀 더 정확한 좌석 상태를 기준으로 사용하는것이 좋다고 판단  

### 결론: **전체 좌석 상태가 배정('ASSIGNED')된 경우를 기준으로 산정**

## 점수 산정
- 티켓팅 오픈 시간부터 마지막 좌석 결제까지의 시간차이를 이용 (마지막 좌석 결제 시간 - 티켓팅 오픈시간)
> **현재 티켓팅 오픈 시간 정보없음 concert 테이블 필드 추가 및 추가 검증 필요함**
> **concert 테이블 매진시간 필드도 추가**

### 동일 점수 처리 방안
티켓팅 오픈 시간부터 마지막 좌석 결제 시간의 차이가 동일하면 어떻게 처리할것인가
- 전체 좌석수가 많은 콘서트가 우선 순위
   - 현재 날짜별 좌석개수는 50개로 고정되어있음
   - 따라서 콘서트 개최 날짜가 많으면 우선 순위

**그래도 동일하면?**
- 콘서트 티켓팅 오픈시간이 먼저인것이 우선순위로 결정

**정리**
1. (마지막 좌석 결제 시간 - 티켓팅 오픈시간) 짧은 
2. 콘서트 개최 날짜가 많은
3. 오픈시간이 먼저

> 이 정도만 고려해도 동일 점수에 대한 대안이 충분하다고 생각된다  
> 그래도 동일하면 Sorted Set의 정렬 규칙사용

### 추가 고려사항 
#### 콘서트의 명칭이 중복된다면?
> 예) 2023 싸이 흠뻑쇼, 2024 싸이 흠뻑쇼 등

갱신할 것인지 개별 콘서트로 랭킹 산정할 것인지  
**결론: 고유한 concertId별로 랭킹 산정(개별로 본다)**

## 구현 방식 
> Redis Sorted Set 자료구조 사용하여 구현  
> ```ZADD concertSoldOutRank {점수} {ConcertId} ```   

### 점수 계산 방식
- 문제점
  - 매진시간 - 오픈시간: 짧은 순
  - 콘서트 개최 날짜: 많은 순
  - 오픈시간: 오래된순

일관되게 높은 값이나 낮은 값을 사용해야함

### 랭킹 데이터 집계 방식
랭킹 데이터를 어디까지 집계할지
1. 상위 랭킹만 관리
2. 전체 콘서트

전체 콘서트 랭킹이 필요할지?  
DB에 데이터 백업하는데 굳이 Redis에서 전체 콘서트 랭킹 저장할 필요없을듯
Redis에서 상위 100위 까지만 저장

> Redis에서 최대 저장 개수를 지정하는 옵션 부재  
> ZREMRANGEBYRANK key 100 -1 명령어를 통해  
> 랭킹 저장 후 100개까지 잘라줘야함  
> 저장 -> 100위까지 자르기 원자적으로 수행 (Lua 스크립트 활용하면 좋을듯)

### 랭킹 갱신 방식
1. 좌석 결제시 이벤트 발행 ->  비동기 처리
   - 실시간성 좋음
2. 스케줄러 사용
   - 매일 or 시간별 스케줄러 동작
   - 실시간성 부족함

### 랭킹 데이터 관리 방식
랭킹 데이터 어떻게 관리할 것인지
1. Redis에서만 관리
   * 영속성 보장은 어떻게 할것인가
   * 랭킹 데이터가 많아질 시 어떻게 관리할것인가
2. RDB와 같이 관리
   * Redis와의 데이터 정합성은 어떻게 고려할것인가

DB와 같이 관리하는데 DB는 백업용으로 스케줄러 사용해 백업  
그럼 백업은 어떤방식으로 할지?
